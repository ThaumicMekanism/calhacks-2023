{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nexports.__esModule = true;\nexports.default = prepareDestination;\nvar _querystring = require(\"./querystring\");\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction prepareDestination(destination, params, query, appendParamsToQuery, basePath) {\n  let parsedDestination = {};\n  if (destination.startsWith('/')) {\n    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href\n    } = new URL(destination);\n    parsedDestination = {\n      pathname,\n      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href\n    };\n  }\n  const destQuery = parsedDestination.query;\n  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n  const destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  const destPathParams = destPathParamKeys.map(key => key.name);\n  let destinationCompiler = pathToRegexp.compile(destPath,\n  // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let newUrl; // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`;\n      const queryCompiler = pathToRegexp.compile(value, {\n        validate: false\n      });\n      value = queryCompiler(params).substr(1);\n    }\n    destQuery[key] = value;\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params);\n  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key];\n      }\n    }\n  }\n  const shouldAddBasePath = destination.startsWith('/') && basePath;\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(params)}`;\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`);\n    }\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);\n  return {\n    newUrl,\n    parsedDestination\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["prepareDestination","destination","params","query","appendParamsToQuery","basePath","parsedDestination","startsWith","pathname","searchParams","hash","hostname","port","protocol","search","href","URL","destQuery","destPath","destPathParamKeys","pathToRegexp","destPathParams","map","key","name","destinationCompiler","compile","validate","newUrl","strOrArray","Object","entries","value","Array","isArray","queryCompiler","substr","paramKeys","keys","some","includes","shouldAddBasePath","split","err","message","match","Error"],"mappings":"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","sourcesContent":["import { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\ntype Params = { [param: string]: any }\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean,\n  basePath: string\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`\n      const queryCompiler = pathToRegexp.compile(value, { validate: false })\n      value = queryCompiler(params).substr(1)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params)\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  const shouldAddBasePath = destination.startsWith('/') && basePath\n\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(\n      params\n    )}`\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete parsedDestination.search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}