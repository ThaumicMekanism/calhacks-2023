{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.closePing = closePing;\nexports.setupPing = setupPing;\nexports.currentPage = void 0;\nvar _unfetch = _interopRequireDefault(require(\"next/dist/build/polyfills/unfetch\"));\nvar _eventsource = require(\"./error-overlay/eventsource\"); /* global location */\nvar evtSource;\nvar currentPage;\nexports.currentPage = currentPage;\nfunction closePing() {\n  if (evtSource) evtSource.close();\n  evtSource = null;\n}\nfunction setupPing(assetPrefix, pathnameFn, retry) {\n  var pathname = pathnameFn(); // Make sure to only create new EventSource request if page has changed\n  if (pathname === currentPage && !retry) return;\n  exports.currentPage = currentPage = pathname; // close current EventSource connection\n  closePing();\n  var url = \"\".concat(assetPrefix, \"/_next/webpack-hmr?page=\").concat(currentPage);\n  evtSource = (0, _eventsource.getEventSourceWrapper)({\n    path: url,\n    timeout: 5000,\n    ondemand: 1\n  });\n  evtSource.addMessageListener(function (event) {\n    if (event.data.indexOf('{') === -1) return;\n    try {\n      var payload = JSON.parse(event.data);\n      if (payload.invalid) {\n        // Payload can be invalid even if the page does not exist.\n        // So, we need to make sure it exists before reloading.\n        (0, _unfetch[\"default\"])(location.href, {\n          credentials: 'same-origin'\n        }).then(function (pageRes) {\n          if (pageRes.status === 200) {\n            location.reload();\n          }\n        });\n      }\n    } catch (err) {\n      console.error('on-demand-entries failed to parse response', err);\n    }\n  });\n}","map":{"version":3,"sources":["../../../client/dev/on-demand-entries-utils.js"],"names":["evtSource","currentPage","closePing","close","setupPing","assetPrefix","pathnameFn","retry","pathname","url","path","timeout","ondemand","addMessageListener","event","data","indexOf","payload","JSON","parse","invalid","location","href","credentials","then","pageRes","status","reload","err","console","error"],"mappings":";;;;;;;AAEA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,mCAAA,CAAA,CAAA;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,6BAAA,CAAA,CAHA;AAKA,IAAIA,SAAJ;AACO,IAAIC,WAAJ;;AAEA,SAASC,SAAT,CAAA,EAAqB;EAC1B,IAAIF,SAAJ,EAAeA,SAAS,CAACG,KAAVH,CAAAA,CAAAA;EACfA,SAAS,GAAG,IAAZA;AACD;AAEM,SAASI,SAAT,CAAmBC,WAAnB,EAAgCC,UAAhC,EAA4CC,KAA5C,EAAmD;EACxD,IAAMC,QAAQ,GAAGF,UAAU,CAAA,CAA3B,CAEA;EACA,IAAIE,QAAQ,KAAKP,WAAbO,IAA4B,CAACD,KAAjC,EAAwC;EACxC,OAAA,CAAA,WAAA,GAAA,WAAW,GAAGC,QAAd,CACA;EACAN,SAAS,CAAA,CAAA;EAET,IAAMO,GAAG,MAAA,MAAA,CAAMJ,WAAY,8BAAA,MAAA,CAA0BJ,WAAY,CAAjE;EACAD,SAAS,GAAG,CAAA,CAAA,EAAA,YAAA,CAAA,qBAAA,EAAsB;IAAEU,IAAI,EAAED,GAAR;IAAaE,OAAO,EAAE,IAAtB;IAA4BC,QAAQ,EAAE;EAAtC,CAAtB,CAAZZ;EAEAA,SAAS,CAACa,kBAAVb,CAA8Bc,UAAAA,KAAD,EAAW;IACtC,IAAIA,KAAK,CAACC,IAAND,CAAWE,OAAXF,CAAmB,GAAnBA,CAAAA,KAA4B,CAAC,CAAjC,EAAoC;IACpC,IAAI;MACF,IAAMG,OAAO,GAAGC,IAAI,CAACC,KAALD,CAAWJ,KAAK,CAACC,IAAjBG,CAAhB;MACA,IAAID,OAAO,CAACG,OAAZ,EAAqB;QACnB;QACA;QACA,CAAA,CAAA,EAAA,QAAA,WAAA,EAAMC,QAAQ,CAACC,IAAf,EAAqB;UACnBC,WAAW,EAAE;QADM,CAArB,CAAA,CAEGC,IAFH,CAESC,UAAAA,OAAD,EAAa;UACnB,IAAIA,OAAO,CAACC,MAARD,KAAmB,GAAvB,EAA4B;YAC1BJ,QAAQ,CAACM,MAATN,CAAAA,CAAAA;UACD;QACF,CAND,CAAA;MAOD;IACF,CAAC,QAAOO,GAAP,EAAY;MACZC,OAAO,CAACC,KAARD,CAAc,4CAAdA,EAA4DD,GAA5DC,CAAAA;IACD;EACF,CAlBD7B,CAAAA;AAmBD","sourcesContent":["/* global location */\n\nimport fetch from 'next/dist/build/polyfills/unfetch'\nimport { getEventSourceWrapper } from './error-overlay/eventsource'\n\nlet evtSource\nexport let currentPage\n\nexport function closePing() {\n  if (evtSource) evtSource.close()\n  evtSource = null\n}\n\nexport function setupPing(assetPrefix, pathnameFn, retry) {\n  const pathname = pathnameFn()\n\n  // Make sure to only create new EventSource request if page has changed\n  if (pathname === currentPage && !retry) return\n  currentPage = pathname\n  // close current EventSource connection\n  closePing()\n\n  const url = `${assetPrefix}/_next/webpack-hmr?page=${currentPage}`\n  evtSource = getEventSourceWrapper({ path: url, timeout: 5000, ondemand: 1 })\n\n  evtSource.addMessageListener((event) => {\n    if (event.data.indexOf('{') === -1) return\n    try {\n      const payload = JSON.parse(event.data)\n      if (payload.invalid) {\n        // Payload can be invalid even if the page does not exist.\n        // So, we need to make sure it exists before reloading.\n        fetch(location.href, {\n          credentials: 'same-origin',\n        }).then((pageRes) => {\n          if (pageRes.status === 200) {\n            location.reload()\n          }\n        })\n      }\n    } catch (err) {\n      console.error('on-demand-entries failed to parse response', err)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}