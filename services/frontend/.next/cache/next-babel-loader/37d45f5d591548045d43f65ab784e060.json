{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nexports.__esModule = true;\nexports[\"default\"] = prepareDestination;\nvar _querystring = require(\"./querystring\");\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\nvar pathToRegexp = _interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction prepareDestination(destination, params, query, appendParamsToQuery, basePath) {\n  var parsedDestination = {};\n  if (destination.startsWith('/')) {\n    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n  } else {\n    var _URL = new URL(destination),\n      pathname = _URL.pathname,\n      searchParams = _URL.searchParams,\n      hash = _URL.hash,\n      hostname = _URL.hostname,\n      port = _URL.port,\n      protocol = _URL.protocol,\n      search = _URL.search,\n      href = _URL.href;\n    parsedDestination = {\n      pathname: pathname,\n      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n      hash: hash,\n      protocol: protocol,\n      hostname: hostname,\n      port: port,\n      search: search,\n      href: href\n    };\n  }\n  var destQuery = parsedDestination.query;\n  var destPath = \"\".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');\n  var destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  var destPathParams = destPathParamKeys.map(function (key) {\n    return key.name;\n  });\n  var destinationCompiler = pathToRegexp.compile(destPath,\n  // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  var newUrl; // update any params in query values\n  for (var _i = 0, _Object$entries = Object.entries(destQuery); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      key = _Object$entries$_i[0],\n      strOrArray = _Object$entries$_i[1];\n    var value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = \"/\".concat(value);\n      var queryCompiler = pathToRegexp.compile(value, {\n        validate: false\n      });\n      value = queryCompiler(params).substr(1);\n    }\n    destQuery[key] = value;\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  var paramKeys = Object.keys(params);\n  if (appendParamsToQuery && !paramKeys.some(function (key) {\n    return destPathParams.includes(key);\n  })) {\n    var _iterator = _createForOfIteratorHelper(paramKeys),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _key = _step.value;\n        if (!(_key in destQuery)) {\n          destQuery[_key] = params[_key];\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  var shouldAddBasePath = destination.startsWith('/') && basePath;\n  try {\n    newUrl = \"\".concat(shouldAddBasePath ? basePath : '').concat(destinationCompiler(params));\n    var _newUrl$split = newUrl.split('#'),\n      _newUrl$split2 = _slicedToArray(_newUrl$split, 2),\n      _pathname = _newUrl$split2[0],\n      _hash = _newUrl$split2[1];\n    parsedDestination.pathname = _pathname;\n    parsedDestination.hash = \"\".concat(_hash ? '#' : '').concat(_hash || '');\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\"To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match\");\n    }\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);\n  return {\n    newUrl: newUrl,\n    parsedDestination: parsedDestination\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["prepareDestination","destination","params","query","appendParamsToQuery","basePath","parsedDestination","startsWith","pathname","searchParams","hash","hostname","port","protocol","search","href","URL","destQuery","destPath","destPathParamKeys","pathToRegexp","destPathParams","map","key","name","destinationCompiler","compile","validate","newUrl","strOrArray","Object","entries","value","Array","isArray","queryCompiler","substr","paramKeys","keys","some","includes","shouldAddBasePath","split","err","message","match","Error"],"mappings":"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","sourcesContent":["import { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\ntype Params = { [param: string]: any }\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean,\n  basePath: string\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`\n      const queryCompiler = pathToRegexp.compile(value, { validate: false })\n      value = queryCompiler(params).substr(1)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params)\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  const shouldAddBasePath = destination.startsWith('/') && basePath\n\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(\n      params\n    )}`\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete parsedDestination.search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}