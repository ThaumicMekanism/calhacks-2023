{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.parseRelativeUrl = parseRelativeUrl;\nvar _utils = require(\"../../utils\");\nvar _querystring = require(\"./querystring\");\nvar DUMMY_BASE = new URL(false ? 'http://n' : (0, _utils.getLocationOrigin)()); /**\n                                                                                * Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative\n                                                                                * (e.g. `./hello`) then at least base must be.\n                                                                                * Absolute urls are rejected with one exception, in the browser, absolute urls that are on\n                                                                                * the current origin will be parsed as relative\n                                                                                */\nfunction parseRelativeUrl(url, base) {\n  var resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE;\n  var _URL = new URL(url, resolvedBase),\n    pathname = _URL.pathname,\n    searchParams = _URL.searchParams,\n    search = _URL.search,\n    hash = _URL.hash,\n    href = _URL.href,\n    origin = _URL.origin,\n    protocol = _URL.protocol;\n  if (origin !== DUMMY_BASE.origin || protocol !== 'http:' && protocol !== 'https:') {\n    throw new Error('invariant: invalid relative URL');\n  }\n  return {\n    pathname: pathname,\n    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n    search: search,\n    hash: hash,\n    href: href.slice(DUMMY_BASE.origin.length)\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/parse-relative-url.ts"],"names":["DUMMY_BASE","URL","parseRelativeUrl","url","base","resolvedBase","pathname","searchParams","search","hash","href","origin","protocol","Error","query","slice","length"],"mappings":";;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA,IAAMA,UAAU,GAAG,IAAIC,GAAJ,CACjB,QAAgC,UAAhC,GAA6C,CAAA,CAAA,EAAA,MAAA,CAAA,iBAAA,EAAA,CAD5B,CAAnB,CAIA;;;;;;AAMO,SAASC,gBAAT,CAA0BC,GAA1B,EAAuCC,IAAvC,EAAsD;EAC3D,IAAMC,YAAY,GAAGD,IAAI,GAAG,IAAIH,GAAJ,CAAQG,IAAR,EAAcJ,UAAd,CAAH,GAA+BA,UAAxD;EACA,IAAA,IAAA,GAQI,IAAIC,GAAJ,CAAQE,GAAR,EAAaE,YAAb,CARJ;IACEC,QADI,GAAA,IAAA,CACJA,QADI;IAEJC,YAFI,GAAA,IAAA,CAEJA,YAFI;IAGJC,MAHI,GAAA,IAAA,CAGJA,MAHI;IAIJC,IAJI,GAAA,IAAA,CAIJA,IAJI;IAKJC,IALI,GAAA,IAAA,CAKJA,IALI;IAMJC,MANI,GAAA,IAAA,CAMJA,MANI;IAOJC,QAPI,GAAA,IAAA,CAOJA,QAPI;EASN,IACED,MAAM,KAAKX,UAAU,CAACW,MAAtBA,IACCC,QAAQ,KAAK,OAAbA,IAAwBA,QAAQ,KAAK,QAFxC,EAGE;IACA,MAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;EACD;EACD,OAAO;IACLP,QADK,EACLA,QADK;IAELQ,KAAK,EAAE,CAAA,CAAA,EAAA,YAAA,CAAA,sBAAA,EAAuBP,YAAvB,CAFF;IAGLC,MAHK,EAGLA,MAHK;IAILC,IAJK,EAILA,IAJK;IAKLC,IAAI,EAAEA,IAAI,CAACK,KAALL,CAAWV,UAAU,CAACW,MAAXX,CAAkBgB,MAA7BN;EALD,CAAP;AAOD","sourcesContent":["import { getLocationOrigin } from '../../utils'\nimport { searchParamsToUrlQuery } from './querystring'\n\nconst DUMMY_BASE = new URL(\n  typeof window === 'undefined' ? 'http://n' : getLocationOrigin()\n)\n\n/**\n * Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative\n * (e.g. `./hello`) then at least base must be.\n * Absolute urls are rejected with one exception, in the browser, absolute urls that are on\n * the current origin will be parsed as relative\n */\nexport function parseRelativeUrl(url: string, base?: string) {\n  const resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE\n  const {\n    pathname,\n    searchParams,\n    search,\n    hash,\n    href,\n    origin,\n    protocol,\n  } = new URL(url, resolvedBase)\n  if (\n    origin !== DUMMY_BASE.origin ||\n    (protocol !== 'http:' && protocol !== 'https:')\n  ) {\n    throw new Error('invariant: invalid relative URL')\n  }\n  return {\n    pathname,\n    query: searchParamsToUrlQuery(searchParams),\n    search,\n    hash,\n    href: href.slice(DUMMY_BASE.origin.length),\n  }\n}\n"]},"metadata":{},"sourceType":"script"}