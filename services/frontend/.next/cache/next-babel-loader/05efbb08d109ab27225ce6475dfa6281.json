{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\nfunction parseParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n  const repeat = param.startsWith('...');\n  if (repeat) {\n    param = param.slice(3);\n  }\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\nfunction getRouteRegex(normalizedRoute) {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/').slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  const parameterizedRoute = segments.map(segment => {\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n      const {\n        key,\n        optional,\n        repeat\n      } = parseParameter(segment.slice(1, -1));\n      groups[key] = {\n        pos: groupIndex++,\n        repeat,\n        optional\n      };\n      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n    } else {\n      return `/${escapeRegex(segment)}`;\n    }\n  }).join(''); // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (true) {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters\n    const getSafeRouteKey = () => {\n      let routeKey = '';\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode);\n        routeKeyCharCode++;\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++;\n          routeKeyCharCode = 97;\n        }\n      }\n      return routeKey;\n    };\n    const routeKeys = {};\n    let namedParameterizedRoute = segments.map(segment => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1)); // replace any non-word characters since they can break\n        // the named regex\n        let cleanedKey = key.replace(/\\W/g, '');\n        let invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n        if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n          invalidKey = true;\n        }\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n      } else {\n        return `/${escapeRegex(segment)}`;\n      }\n    }).join('');\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`\n    };\n  }\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-regex.ts"],"names":["escapeRegex","str","replace","parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","getRouteRegex","normalizedRoute","segments","split","groups","groupIndex","parameterizedRoute","map","segment","pos","join","routeKeyCharCode","routeKeyCharLength","getSafeRouteKey","routeKey","i","String","fromCharCode","routeKeys","namedParameterizedRoute","cleanedKey","invalidKey","length","isNaN","parseInt","substr","re","RegExp","namedRegex"],"mappings":"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","sourcesContent":["interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\n// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nfunction parseParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nexport function getRouteRegex(\n  normalizedRoute: string\n): {\n  re: RegExp\n  namedRegex?: string\n  routeKeys?: { [named: string]: string }\n  groups: { [groupName: string]: Group }\n} {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/')\n    .slice(1)\n    .split('/')\n\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  const parameterizedRoute = segments\n    .map((segment) => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n        groups[key] = { pos: groupIndex++, repeat, optional }\n        return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n      } else {\n        return `/${escapeRegex(segment)}`\n      }\n    })\n    .join('')\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    let routeKeyCharCode = 97\n    let routeKeyCharLength = 1\n\n    // builds a minimal routeKey using only a-z and minimal number of characters\n    const getSafeRouteKey = () => {\n      let routeKey = ''\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode)\n        routeKeyCharCode++\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++\n          routeKeyCharCode = 97\n        }\n      }\n      return routeKey\n    }\n\n    const routeKeys: { [named: string]: string } = {}\n\n    let namedParameterizedRoute = segments\n      .map((segment) => {\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n          const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n          // replace any non-word characters since they can break\n          // the named regex\n          let cleanedKey = key.replace(/\\W/g, '')\n          let invalidKey = false\n\n          // check if the key is still invalid and fallback to using a known\n          // safe key\n          if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n            invalidKey = true\n          }\n          if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n            invalidKey = true\n          }\n\n          if (invalidKey) {\n            cleanedKey = getSafeRouteKey()\n          }\n\n          routeKeys[cleanedKey] = key\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`\n        } else {\n          return `/${escapeRegex(segment)}`\n        }\n      })\n      .join('')\n\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`,\n    }\n  }\n\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}