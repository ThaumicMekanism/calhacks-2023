{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getRouteMatcher = getRouteMatcher;\nfunction getRouteMatcher(routeRegex) {\n  var re = routeRegex.re,\n    groups = routeRegex.groups;\n  return function (pathname) {\n    var routeMatch = re.exec(pathname);\n    if (!routeMatch) {\n      return false;\n    }\n    var decode = function decode(param) {\n      try {\n        return decodeURIComponent(param);\n      } catch (_) {\n        var err = new Error('failed to decode param');\n        err.code = 'DECODE_FAILED';\n        throw err;\n      }\n    };\n    var params = {};\n    Object.keys(groups).forEach(function (slugName) {\n      var g = groups[slugName];\n      var m = routeMatch[g.pos];\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {\n          return decode(entry);\n        }) : g.repeat ? [decode(m)] : decode(m);\n      }\n    });\n    return params;\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-matcher.ts"],"names":["getRouteMatcher","routeRegex","re","groups","pathname","routeMatch","exec","decode","param","decodeURIComponent","_","err","Error","code","params","Object","keys","forEach","slugName","g","m","pos","undefined","indexOf","split","map","entry","repeat"],"mappings":";;;;AAEO,SAASA,eAAT,CAAyBC,UAAzB,EAAuE;EAC5E,IAAQC,EAAF,GAAiBD,UAAvB,CAAQC,EAAF;IAAMC,MAAN,GAAiBF,UAAvB,CAAYE,MAAN;EACN,OAAQC,UAAAA,QAAD,EAAyC;IAC9C,IAAMC,UAAU,GAAGH,EAAE,CAACI,IAAHJ,CAAQE,QAARF,CAAnB;IACA,IAAI,CAACG,UAAL,EAAiB;MACf,OAAO,KAAP;IACD;IAED,IAAME,MAAM,GAAIC,SAAVD,MAAM,CAAIC,KAAD,EAAmB;MAChC,IAAI;QACF,OAAOC,kBAAkB,CAACD,KAAD,CAAzB;MACD,CAAC,QAAOE,CAAP,EAAU;QACV,IAAMC,GAA8B,GAAG,IAAIC,KAAJ,CACrC,wBADqC,CAAvC;QAGAD,GAAG,CAACE,IAAJF,GAAW,eAAXA;QACA,MAAMA,GAAN;MACD;IACF,CAVD;IAWA,IAAMG,MAAkD,GAAG,CAAA,CAA3D;IAEAC,MAAM,CAACC,IAAPD,CAAYZ,MAAZY,CAAAA,CAAoBE,OAApBF,CAA6BG,UAAAA,QAAD,EAAsB;MAChD,IAAMC,CAAC,GAAGhB,MAAM,CAACe,QAAD,CAAhB;MACA,IAAME,CAAC,GAAGf,UAAU,CAACc,CAAC,CAACE,GAAH,CAApB;MACA,IAAID,CAAC,KAAKE,SAAV,EAAqB;QACnBR,MAAM,CAACI,QAAD,CAANJ,GAAmB,CAACM,CAAC,CAACG,OAAFH,CAAU,GAAVA,CAAD,GACfA,CAAC,CAACI,KAAFJ,CAAQ,GAARA,CAAAA,CAAaK,GAAbL,CAAkBM,UAAAA,KAAD;UAAA,OAAWnB,MAAM,CAACmB,KAAD,CAAlCN;QAAAA,EADe,GAEfD,CAAC,CAACQ,MAAFR,GACA,CAACZ,MAAM,CAACa,CAAD,CAAP,CADAD,GAEAZ,MAAM,CAACa,CAAD,CAJVN;MAKD;IACF,CAVDC,CAAAA;IAWA,OAAOD,MAAP;EACD,CA/BD;AAgCD","sourcesContent":["import { getRouteRegex } from './route-regex'\n\nexport function getRouteMatcher(routeRegex: ReturnType<typeof getRouteRegex>) {\n  const { re, groups } = routeRegex\n  return (pathname: string | null | undefined) => {\n    const routeMatch = re.exec(pathname!)\n    if (!routeMatch) {\n      return false\n    }\n\n    const decode = (param: string) => {\n      try {\n        return decodeURIComponent(param)\n      } catch (_) {\n        const err: Error & { code?: string } = new Error(\n          'failed to decode param'\n        )\n        err.code = 'DECODE_FAILED'\n        throw err\n      }\n    }\n    const params: { [paramName: string]: string | string[] } = {}\n\n    Object.keys(groups).forEach((slugName: string) => {\n      const g = groups[slugName]\n      const m = routeMatch[g.pos]\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/')\n          ? m.split('/').map((entry) => decode(entry))\n          : g.repeat\n          ? [decode(m)]\n          : decode(m)\n      }\n    })\n    return params\n  }\n}\n"]},"metadata":{},"sourceType":"script"}